Isaac Pontarelli
A4 Design Document
CSC 411 3/6/2020

Testing Strategy:
=================
To choose the denominator I will need to do some testing to see the file size,
visual artifacts, and if there is any effect on the autograder.

To test the functions I write I will design custom test cases and pass them
through first the individual functions and then their invers. This way I can
assert that, for example, a pixel converted from rgb to component then back to
rgb remains roughly the same ( given in this instance their may be some loss
of data due to bounding).


Architecture:
=============

I will implement 2 modules in a addition to bitpack and image. One for all the
conversions and formulas involved with component video space and another for
the io involved with the images themselves.


- image.c

	This file will be very high level. It will take care of argument 
handling and call a few functions from the different interfaces. If compressing
it will call fuctions from the imageIO to read the image, then from operations 
to convert the image, then from imageIO again to pack into words and write.
The same order applies for unCompressing, just with different functions.


- bitpack.c

	
operations.h/.c
---------------

void* prepCompress(pixmap* img)
	- public function
	- call RGBToComonent(img) 
	- iterate over 2x2 block, for each:
		- call avgChroma() to get Pb and Pr
		- call DCT() for a, b, c
	- return pixmap with a, b, c, d, Pb, Pr values as pixels

void* prepDecompress(pixmap* img)
	- public function 
	- takes in pixmap with a, b, c, d, Pb, Pr values as pixels
	- iterates over generating 2x2 blocks
		- call inverseDCT
		- call componentToRGB
		- write pixels		
	
unsigned avgChroma(*pix1, *pix2, *pix3, *pix4)
	- private function
	- compute average Pb and Pr values given pixels
	- use Arith_index_of_chroma() to get quantized representation (4 bits)
	- returns quantized representation

void RGBToComponent(pixmap* rgb)
	- private function
	- converts every pixel in the pixmap to component space using given formulas
	- since component and rgb are both unsigned ints at this stage, inplace works

void componentToRGB(pixmap component)
	- private function
	- converts every pixel in to rgb space using given formulas
	- since component and rgb are both unsigned ints at this stage, inplace works

unsigned* DCT(*pix1, *pix2, *pix3, *pix4)
	- private function
	- tranforms four luminance values into a, b, c, d using given formulas
	- limit b, c, d to (-0.3, 0.3)
	- return array of a, b, c, d

unsigned* inverseDCT(a, b, c, d)
	- inverse cosign transformation
	- uses given formulas
	- returns y1, y2, y3

imageIO.h/.c
------------

void readCompressed(File* f, pixmap* img)
	- read header and set width / height
	- read code words
	- extract a, b, c, d, Pb, Pr from each codeword
		- write into component pixels

void readUncompressed(File* f, pixmap* img)
	- read each colored pixel using pnm.h
	- return pixmap* generated by pnm.h 
	
void writeCompressed(File* f, pixmap* img)
	- write header
	- pack each a, b, c, d, Pb, Pr value set into a word using bitpack
	- write each word to f

void writeUncompressed(File* f, pixmap* image)
	- write using pnm.h 

Overall Design:
===============

                  +---------+
                  |         |
                  | image.c |
                  |         |
                  +---------+
                  |         |
                  +         +
            imageIO.h      operations.h
                  +            +
                  |            |
                  |            |
          +-------+---+  +-----+--------+
          |           |  |              |
  +-------+ imageIO.c |  | operations.c |
  |       |           |  |              |
  |       +----+------+  +--------------+
  |            |
  |            +
  |          Bitpack.h
  |            +
  |            |
  |            |
  |        +---+-------+
  +        |           |
pnm.h      | Bitpack.c |
           |           |
           +-----------+

Information Loss:
=================

There are several places where information may be lost when compressing and 
decompressing an image.

- The averaging of the chroma values loses resolution.
- The quantization of the avg chroma values may result in loss of information at
the extremas.


Invariants:
===========
Representation Invariants: In the world of ideas, a rgbPixel struct will 
represent a pixel in a pnm image. It will have r, g, and b members

Representation Invariant: In the world of ideas, a componentPixel struct 
will represent a pixel in component video. It will have Y, Pr and Pb members

Invariant: A rgbPixel struct will always represent a single pixel, not a 2x2
block 

Invariant: Bitpack will never know information about the image it is compressing







